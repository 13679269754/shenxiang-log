2025-09-24
## **double write 与redo 的关系**
1. **double write 是 redo log 生效的前提**：
   
    只有确保数据页的完整性（无部分写），redo log 重放时才能基于正确的页数据进行修改，否则会导致数据混乱。
    
2. **redo log 补充 double write 的不足**：

    double write 仅保障数据页的完整写入，但无法记录 “未刷盘的脏页修改”。redo log 则记录所有事务修改，确保即使数据页未写入磁盘，崩溃后也能通过重放日志恢复。
    
3. **共同目标**：
   
    两者配合实现了 InnoDB 的 “crash-safe”（崩溃安全）能力 —— 既保证数据页物理完整性，又保证事务修改不丢失。
    


### 对于"**Oracle 中事务commit的时间是平均的**（大事务和小事务提交时间一样），**mysql中并不是这样的。**"的理解

oracle 没有binlog，其但有 **归档日志（Archive Log）** 和 **联机重做日志（Online Redo Log）**，其日志写入和刷盘逻辑与 MySQL 有差异（它们都是物理日志，不需要保证日志的顺序性），事务在执行时就会写redo log。提交时并应为事务大小而有额外的消耗。
mysql 中由于要写binlog，而binlog是有顺序的，且在事务提交时才会写入。所以，大事务会导致，binlog 等待大事务的io，因此提交时间变长。

![[Pasted image 20250924175020.png]]

## recover流程

1. 根据当前的checkpoint 点位，读取redo log 中的lsn 大于checkpoint 的事务编号；
2. 读取当前最后一个binlog文件中的所有事务编号。
3. 对比两个集合，以binlog 事务集合为准, 
	binlog 中有的事务，触发前滚，commit；
	binlog 中没有的事务触发，回滚,rollback；
4. 当有数据页被写坏时，需要根据double write 文件来重新写错误页。