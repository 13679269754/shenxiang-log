| operator | createtime | updatetime |
| ---- | ---- | ---- |
| shenx | 2025-7月-03 | 2025-7月-03  |
| ... | ... | ... |
---
## 写入系统调用

[toc]

在操作系统编程中，`write` 和 `pwrite` 都是用于向文件或设备写入数据的系统调用，但它们在使用方式和行为上存在关键区别。以下是两者的详细对比：


### **一、基本定义与原型**
#### 1. **`write` 函数**
```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```
- **功能**：从 `buf` 缓冲区向文件描述符 `fd` 对应的文件写入 `count` 字节数据。
- **特点**：依赖文件的当前偏移量（由 `lseek` 或上次读写操作决定），写入后偏移量会增加。

#### 2. **`pwrite` 函数**
```c
#include <unistd.h>
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
```
- **功能**：从 `buf` 缓冲区向文件描述符 `fd` 对应的文件写入 `count` 字节数据，但**指定写入位置为 `offset`**。
- **特点**：不影响文件的当前偏移量，写入操作是原子的（即指定位置写入和偏移量更新不可被中断）。


### **二、核心区别对比**
| **维度**         | **`write`**                          | **`pwrite`**                         |
|------------------|--------------------------------------|--------------------------------------|
| **偏移量控制**   | 依赖文件当前偏移量（由 `lseek` 维护）| 直接指定偏移量 `offset`，不影响当前偏移量 |
| **原子性**       | 非原子操作（写入过程中偏移量可能被其他线程/进程修改） | 原子操作（指定位置写入和偏移量更新不可分割） |
| **线程安全性**   | 非线程安全（多线程共用文件偏移量可能导致竞态条件） | 线程安全（各线程独立指定偏移量，互不干扰） |
| **典型场景**     | 顺序写入（如日志追加、文件填充）     | 随机写入（如数据库索引更新、文件特定位置修改） |


### **三、示例对比**
#### 1. **`write` 的使用**
```c
// 假设 fd 指向一个空文件（偏移量为0）
char buf[] = "Hello";
write(fd, buf, 5);  // 写入 "Hello"，偏移量变为5
write(fd, " World", 6);  // 追加 " World"，偏移量变为11
// 文件内容："Hello World"
```

#### 2. **`pwrite` 的使用**
```c
// 假设 fd 指向一个文件，内容为 "Hello World"（偏移量为11）
char buf[] = "Linux";
pwrite(fd, buf, 5, 6);  // 在偏移量6处写入 "Linux"，覆盖 "World"
// 文件内容变为 "Hello Linux"，但当前偏移量仍为11（未改变）
```


### **四、深入理解**
#### 1. **原子性优势**
- `pwrite` 的原子性避免了多线程环境下的竞态条件。例如：
  ```c
  // 线程A
  lseek(fd, 100, SEEK_SET);
  write(fd, "data", 4);  // 若此时线程B修改了偏移量，数据可能写入错误位置

  // 线程B
  lseek(fd, 200, SEEK_SET);
  ```
  使用 `pwrite` 可避免此问题：
  ```c
  // 线程A
  pwrite(fd, "data", 4, 100);  // 直接写入偏移量100处，不受其他线程影响
  ```

#### 2. **应用场景差异**
- **`write`**：适合顺序写入，如：
  - 日志文件追加（`tail -f` 依赖顺序偏移量）。
  - 文件流式写入（如网络数据接收后写入文件）。
- **`pwrite`**：适合随机写入，如：
  - 数据库索引更新（修改B+树特定节点）。
  - 多线程并发写入同一文件不同区域（各线程用 `pwrite` 指定独立偏移量）。


### **五、注意事项**
1. **文件打开模式**：
   - `write` 和 `pwrite` 均要求文件以 `O_WRONLY` 或 `O_RDWR` 模式打开。
   - 若文件以 `O_APPEND` 模式打开，`write` 会强制从文件末尾写入（忽略当前偏移量），但 `pwrite` 仍按指定偏移量写入。

2. **返回值**：
   - 成功时返回实际写入的字节数（可能小于 `count`，需检查并处理）。
   - 失败时返回 `-1` 并设置 `errno`（如 `EINTR`、`EBADF`、`EFBIG` 等）。

3. **兼容性**：
   - `pwrite` 在部分旧系统（如早期Linux内核）可能不支持，需检查系统手册。


### **六、总结**
| **场景**                     | **推荐函数** |
|------------------------------|--------------|
| 顺序写入，依赖文件偏移量     | `write`      |
| 随机写入，需指定位置         | `pwrite`     |
| 多线程并发写入同一文件       | `pwrite`     |
| 需原子性保证（如数据库）     | `pwrite`     |

选择 `write` 还是 `pwrite` 取决于是否需要精确控制写入位置、保证原子性以及避免多线程竞态条件。