# MySQL 监控异常情况处理
在MySQL数据库运维中，通过监控发现异常后，需针对性定位根因并处理。本文梳理了**网络流量异常、主从延迟、慢查询、线程阻塞、CPU占用高、行排序频繁、连接数不足、内存异常**八大常见监控异常场景的处理方法，覆盖问题原因、定位手段和解决思路。

## 1. 读写网络流量异常增加
数据库的网络读写流量突发升高，通常与大数量级的数据操作相关，需区分读/写流量分别分析。

### 读流量异常升高
- **常见原因**：大数据量的数据导出操作、未加限制的全表查询（返回大量结果集的SQL）。
- **定位与处理**：
  1. 查看数据库慢查询日志，筛选返回行数大的查询SQL；
  2. 检查业务侧是否有批量导出、报表统计等大查询操作；
  3. 优化查询：添加分页（`LIMIT`）、创建合适索引、拆分大查询为小查询。

### 写流量异常升高
- **常见原因**：大事务执行、批量插入/更新操作（如业务批量同步数据）。
- **定位与处理**：
  1. **解析binlog日志**：找到流量突增时间段的binlog，提取对应的写入SQL（可使用`mysqlbinlog`工具解析）；
  2. 检查事务大小：避免单事务执行大量DML操作，拆分大事务为小事务；
  3. 限制批量写入速度：对批量插入/更新添加速率控制，避免瞬间压满数据库IO。

## 2. 主从延迟异常升高
主从延迟是MySQL复制架构的核心问题，需根据**单台从库延迟**和**所有从库延迟**两种情形分别排查。

### 情形一：单台从库延迟显著高于其他节点
- **可能原因**：
  1. **网络问题**：该从库与主库之间的网络延迟过高、带宽被占满（可通过`ping`、`iftop`等工具检测）；
  2. **从库性能问题**：从库存在慢SQL、服务器CPU/内存/磁盘IO被其他进程占用，导致复制线程执行缓慢；
  3. **服务器时间同步问题**：从库与主库的系统时间相差过大，表现为延迟在0和N之间跳跃式变化；
  4. **从库IO线程断开**：复制的IO线程异常中断，无法及时拉取主库binlog。
- **处理方法**：
  1. 排查网络：修复网络故障、扩容带宽，确保主从之间网络通畅；
  2. 优化从库性能：分析从库慢查询日志，优化慢SQL；关停从库上的非核心进程，释放服务器资源；
  3. 同步服务器时间：配置NTP时间同步服务，确保主从节点时间偏差在毫秒级；
  4. 重启复制线程：通过`start slave;`重启IO/SQL线程，若线程持续断开，需排查权限或binlog文件缺失问题。

### 情形二：所有从库的延迟均升高
- **可能原因**：
  1. **主库大事务写入**：主库执行了大批量插入/更新/删除的大事务，从库需花费大量时间重放binlog；
  2. **主库执行高开销DML**：主库执行了如`ALTER TABLE`等需重建表的DDL操作，从库复制时需同步表结构变更，导致延迟陡增。
- **处理方法**：
  1. 拆分主库大事务：将批量操作拆分为多个小事务，降低单事务的复制开销；
  2. 避开业务高峰执行DDL：在低峰期执行表结构变更，或使用在线DDL工具（如pt-online-schema-change）减少锁表和复制延迟；
  3. 临时提升从库复制效率：适当调大从库`innodb_flush_log_at_trx_commit`（牺牲部分持久性）、增加复制线程数（MySQL 8.0支持多线程复制）。

## 3. 慢查询数量升高
慢查询数量突发升高会直接导致数据库性能下降，需快速定位慢查询并优化。

- **定位手段**：
  1. 查看对应数据库节点的**慢查询日志**（需提前开启`slow_query_log`），筛选出执行时间长、扫描行数多的SQL；
  2. 使用`EXPLAIN`分析慢查询的执行计划，定位索引失效、全表扫描、多表关联低效等问题；
  3. 结合业务场景，确认慢查询是否为新上线的SQL或业务流量突增导致。
- **处理方法**：
  1. 为慢查询添加合适的索引（如复合索引、覆盖索引）；
  2. 优化SQL语句：避免`SELECT *`、拆分复杂子查询、减少大表关联；
  3. 限制查询结果集：通过`LIMIT`分页，避免返回大量数据；
  4. 临时规避：对非核心业务的慢查询，可临时限流或降级，优先保障核心业务。

## 4. 线程阻塞
线程阻塞主要分为**死锁**和**锁等待**两种情况，需通过监控指标和日志定位问题。

### 死锁
- **定位手段**：
  1. 通过PMM监控指标`mysql_info_schema_innodb_metrics_lock_lock_deadlocks_total`（死锁计数器）判断是否发生死锁；
  2. 查看MySQL的`innodb_status`日志，提取死锁详情（如涉及的表、锁类型、SQL语句）。
- **处理方法**：
  1. 调整业务SQL的执行顺序，避免不同事务同时抢占相同资源；
  2. 缩小事务范围，减少事务持有锁的时间；
  3. 更换锁类型：对读多写少的场景，使用行锁代替表锁，或开启`innodb_locks_unsafe_for_binlog`（谨慎使用）。

### 锁等待
- **定位手段**：
  1. 通过`show processlist`查看阻塞的线程，确认持有锁的SQL和等待锁的SQL；
  2. 结合慢查询日志和主从延迟图表，判断阻塞SQL的影响范围。
- **处理方法**：
  1. 杀死长时间持有锁的慢SQL线程（`kill [线程ID]`），释放锁资源；
  2. 优化持有锁的SQL：减少锁的持有时间，避免在事务中执行非数据库操作；
  3. 对热点表添加锁粒度控制：如拆分热点表，减少锁竞争。

## 5. CPU占用高
CPU占用高分为**iowait升高**和**cpu_load升高**两种场景，根因不同处理方式也不同。

### iowait升高
- **问题原因**：CPU处于等待IO完成的状态，通常是SQL语句缺乏索引，导致全表扫描、扫描大量数据，引发磁盘IO瓶颈，此时SQL多处于`sending data`阶段。
- **处理方法**：
  1. 定位慢查询：筛选出处于`sending data`阶段的SQL，通过`EXPLAIN`分析索引使用情况；
  2. 为SQL添加合适的索引，减少磁盘IO扫描行数；
  3. 优化表结构：对大表进行分区，减少单次查询的扫描范围；
  4. 提升磁盘性能：更换SSD磁盘，或优化RAID策略。

### cpu_load升高
- **问题原因**：服务器整体负载过高，可能是大量并发SQL执行、复杂计算（如聚合函数、子查询）或其他进程占用CPU资源。
- **处理方法**：
  1. 排查非数据库进程：关停服务器上的非核心进程，释放CPU资源；
  2. 优化SQL的CPU开销：减少聚合函数、子查询的使用，拆分复杂SQL；
  3. 限流并发请求：对核心业务的并发量进行限制，避免CPU被打满；
  4. 扩容服务器：对高负载节点进行CPU扩容，或分库分表分担压力。

## 6. 行排序（Sort）操作频繁
- **问题原因**：SQL中使用`GROUP BY`、`ORDER BY`关键字，且分组/排序字段未创建索引，导致MySQL执行文件排序（`Using filesort`），增加CPU和IO开销。
- **定位手段**：通过慢查询日志或`EXPLAIN`执行计划，筛选出包含`Using filesort`的SQL；结合监控图表中的行排序指标，确认高频排序的SQL。
- **处理方法**：
  1. 为分组/排序字段创建索引（复合索引需遵循最左前缀原则）；
  2. 减少排序数据量：通过`WHERE`条件过滤无效数据，再进行排序；
  3. 调整排序方式：对大数据量排序，可将排序逻辑转移到应用层，减轻数据库压力。

## 7. 可用连接数不足
- **问题影响**：可用连接数骤降会导致数据库拒绝新的连接请求，业务出现连接超时错误。
- **监控指标**：关注可用连接数监控图表，当前每台服务器最大连接数为4000（由ProxySQL控制）。
- **处理方法**：
  1. 定位连接数飙升的原因：通过`show processlist`查看异常连接（如长时间未释放的连接、慢查询导致的连接阻塞）；
  2. 优化应用连接池：调整连接池的最大连接数、空闲连接超时时间，避免连接泄漏；
  3. 临时提升最大连接数：在ProxySQL中适当调大最大连接数（需结合服务器资源）；
  4. 杀死无效连接：对长时间空闲的连接执行`kill`操作，释放连接资源。

## 8. 内存使用百分比异常
- **正常情况**：MySQL服务器的大部分内存分配给`innodb_buffer_pool`（用于缓存热点数据），因此可用内存较少是正常现象。
- **异常场景**：内存使用率骤升并持续100%，或内存泄漏导致OOM（内存溢出）。
- **处理方法**：
  1. 检查`innodb_buffer_pool_size`配置：若缓冲区设置过大，可适当调小，避免占用过多系统内存；
  2. 排查内存泄漏：通过`top`、`pmap`工具查看MySQL进程的内存占用，确认是否存在内存泄漏；
  3. 优化缓存策略：清理无效的缓存数据，或对热点数据进行分层缓存（如使用Redis分担数据库缓存压力）；
  4. 扩容服务器内存：若业务数据量持续增长，可扩容服务器内存，满足缓存需求。