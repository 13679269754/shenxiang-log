### Redis中Lua脚本保证原子性的原理与机制  

#### 一、Redis的原子性操作特性  
Redis的**单个命令操作**天然具有原子性，这意味着：  
- 每个命令作为一个整体执行，不会被其他命令打断。  
- 例如`GET`、`SET`、`INCR`等操作都是原子的。  
- 即使多个客户端并发执行命令，Redis也会按顺序处理，确保每个命令完整执行。  

但需要注意：**多个命令的组合操作**并不天然具备原子性。例如以下场景：  
1. 客户端A执行`GET key`获取值。  
2. 客户端B同时执行`GET key`获取值。  
3. 客户端A执行`SET key new_value`。  
4. 客户端B执行`SET key new_value`。  

这种情况下可能出现"竞态条件"，导致数据不一致（类似数据库的丢失更新问题）。  


#### 二、Lua脚本在Redis中的原子性实现  
你提供的Lua脚本通过以下机制保证操作的原子性：  

##### 1. Redis的脚本执行机制  
Redis使用`EVAL`或`EVALSHA`命令执行Lua脚本，其核心特性是：  
- **单线程原子执行**：脚本在Redis服务器的单线程中执行，整个脚本作为一个整体运行，不会被其他命令打断。  
- **全或无执行**：脚本要么全部执行成功，要么全部不执行（除非脚本运行中出错）。  
- **隔离性**：脚本执行期间，其他客户端的命令会被阻塞，直到脚本执行完成。  

##### 2. 脚本原子性的具体体现  
以你的脚本为例：  

```lua
if (redis.call('exists', KEYS[1]) == 1) then
    local stock = tonumber(redis.call('get', KEYS[1]))
    if (stock <= 0) then
        return -1
    end
    redis.call('decr', KEYS[1])
    return stock - 1
else
    return -1
end
``` 

- 从`exists`检查到`decr`操作的整个流程在**同一个原子操作中完成**。  
- 不会出现以下情况：  
  - 检查到库存存在后，其他客户端修改了库存。  
  - `get`获取值后，`decr`操作被其他命令打断。  
- 相当于将多个命令组合成一个"原子操作块"，类似数据库中的事务。  


#### 三、为什么需要Lua脚本实现原子性？  
虽然单个Redis命令是原子的，但组合操作需要额外机制：  

##### 1. 普通命令组合的局限性  
假设不使用脚本，用以下步骤实现库存扣减：  
1. 客户端A执行`GET stock_key`获取库存。  
2. 客户端A判断库存>0。  
3. 客户端A执行`DECR stock_key`。  

如果同时有客户端B执行相同操作，可能出现：  
- 客户端A和B同时获取到库存=1。  
- 客户端A执行`DECR`后库存=0。  
- 客户端B执行`DECR`后库存=-1（超卖问题）。  

##### 2. Lua脚本的优势  
- **避免竞态条件**：将"检查+操作"合并为原子操作。  
- **减少网络往返**：多个命令在服务端一次执行，降低延迟。  
- **保证逻辑一致性**：脚本内的所有操作要么都完成，要么都不完成。  


#### 四、Redis原子性的其他实现方式  
除了Lua脚本，Redis还提供以下原子性方案：  

| 方案         | 特点                                                                 | 适用场景                |  
|--------------|----------------------------------------------------------------------|-------------------------|  
| Lua脚本      | 灵活支持复杂逻辑，单线程原子执行                                     | 复杂组合操作            |  
| 事务（MULTI/EXEC） | 支持命令队列，但不保证原子性（若中间命令出错，后续命令仍会执行）     | 简单命令组合            |  
| 乐观锁（WATCH）  | 监控键变化，事务执行前发现变化则放弃执行                             | 并发控制场景            |  
| 单命令操作   | 单个命令天然原子性                                                   | 简单操作                |  


#### 五、总结  
你的Lua脚本之所以能保证原子性，核心在于：  
1. Redis的单线程模型确保脚本整体执行不被打断。  
2. `EVAL`命令将多个操作封装为一个原子单元。  
3. 从库存检查到扣减的整个流程在同一个"原子操作"中完成。  

这使得脚本能够安全处理并发场景下的库存扣减、分布式锁等需要原子性保证的业务逻辑。  