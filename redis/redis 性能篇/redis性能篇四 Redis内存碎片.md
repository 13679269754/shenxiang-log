| operator | createtime | updatetime |
| ---- | ---- | ---- |
| shenx | 2024-10月-29 | 2024-10月-29  |
| ... | ... | ... |
---
# redis性能篇四 Redis内存碎片.md

[toc]

## 开篇

Redis被广泛使用的一个很重要的原因是它的高性能。因此我们必要要重视所有可能影响Redis性能的因素、机制以及应对方案。影响Redis性能的五大方面的潜在因素，分别是：

*   [Redis内部的阻塞式操作](https://www.cnblogs.com/liang24/p/14231309.html)
*   [CPU核和NUMA架构的影响](https://www.cnblogs.com/liang24/p/14232836.html)
*   [Redis关键系统配置](https://www.cnblogs.com/liang24/p/14232880.html)
*   [Redis内存碎片](https://www.cnblogs.com/liang24/p/14232890.html)
*   [Redis缓冲区](https://www.cnblogs.com/liang24/p/14232895.html)

这一讲，我们来学习一下CPU对Redis的性能影响及应对方法。

Redis被广泛使用的一个很重要的原因是它的高性能。因此我们必要要重视所有可能影响Redis性能的因素、机制以及应对方案。影响Redis性能的五大方面的潜在因素，分别是：

*   [Redis内部的阻塞式操作](https://www.cnblogs.com/liang24/p/14231309.html)
*   [CPU核和NUMA架构的影响](https://www.cnblogs.com/liang24/p/14232836.html)
*   [Redis关键系统配置](https://www.cnblogs.com/liang24/p/14232880.html)
*   [Redis内存碎片](https://www.cnblogs.com/liang24/p/14232890.html)
*   [Redis缓冲区](https://www.cnblogs.com/liang24/p/14232895.html)

这一讲学习Redis的内存空间存储效率问题，探索一下，为什么数据已经删除了，但内存却闲置着没有用，以及相应的解决方案。

## 什么是内存碎片
-------

我们用高铁车厢说明，假设一个车厢的座位总共有60个，现在已经卖 了57张票，需要三张连在一起的票，但发现买不到了，只好换一趟车。我们可以把这些分散的空座位叫作“车厢座位碎片”。

内存碎片类似上面高铁座位的例子。虽然操作系统的剩余空间总量足够，但申请一块连续地址空间N字节时，剩余内存空间中没有大小为N字节的连续空间，那么这些剩余空间就是**内存碎片**。

内存碎片是如何形成的？
-----------

内存碎片形成有内因和外因。

### 内因：内存分配器的分配策略

内存分配器的分配策略决定操作系统无法做到“按需分配”。内存分配器必须分配一块固定大小的连续内存空间。

以jemalloc为例，是按照一系列固定的大小划分内存空间，例如8字节、16字节、32字节、...、2KB、4KB等。当程序申请的内存最接近某个固定值时，jemalloc就会给它分配相应大小的空间。

### 外因：键值对大小不一样和删改操作

一是，前面讲到，内存分配器只能按照固定大小分配内存，所以，分配的内存空间一般都会比申请的空间大一些，不会完全一致，这本身就千万一定的碎片，降低内存空间存储效率。

二是，这些键值被修改和删除，会导致空间的扩容和释放。

大量内存碎片的存在，会造成Redis的内存实际利用率变低。那如何解决这些内存碎片呢？在此之前，我们先来学习如何判断是否有内存碎片。

如何判断是否有内存碎片？
------------

Redis提供INFO命令，用来查询内存使用的详细信息，命令如下：

![](https://assets.cnblogs.com/images/copycode.gif)

INFO memory # Memory
used\_memory:1073741736 used\_memory\_human:1024.00M
used\_memory\_rss:1997159792 used\_memory\_rss\_human:1.86G
…
mem\_fragmentation\_ratio:1.86

![](https://assets.cnblogs.com/images/copycode.gif)

*   mem\_fragmentation\_ratio，表示Redis当前的内存碎片率；
*   used\_memory\_rss，表示操作系统实际分配给Redis的物理内存空间，里面包含了碎片；
*   used\_memory，表示Redis为了保存数据实际申请使用的空间。

**如何使用这个指标？**

*   mem\_fragmentation\_ratio 大于1但小于1.5。这种情况是合理的。
*   mem\_fragmentation\_ratio 大于 1.5 。这表明内存碎片率已经超过了50%。一般情况下，这个时候，我们就需要采取一些措施来降低内存碎片率了。

下面介绍如何清理内存碎片了。

如何清理内存碎片？
---------

一个“简单粗暴”的方法是重启Redis实例。但是这个方法会带来两个后果：

*   如果Redis中的数据没有持久化，数据会丢失；
*   即使Redis数据持久化了，还需要通过AOF或者RDB来恢复，恢复时长取决于AOF或RDB的大小。并且如果只有一个Redis实例，恢复阶段无法提供服务。

那有没有更好的方法呢？有的，从4.0-RC3版本以后，Redis自身提供了一种内存碎片自动清理的方法。

### 内存碎片自动清理

内存碎片清理，简单来说，就是“搬家让位，合并空间”。

当有数据把一块连续的内存空间分割成好几块不连续的空间时，操作系统会把数据拷贝到另外，而原来不连续的内存空间就变成连续的内存空间了。

但是**碎片清理是有代价的**。操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。另外在数据拷贝时，会阻塞Redis，降低性能。

### 如何缓解这个问题？

Redis专门为自动内存碎片清理机制提供参数设置。可以通过设置参数，来控制碎片清理的开始和结束时机，以及占用的CPU比例，从而减少碎片清理对Redis请求处理的性能影响。

首先，开启自动内存碎片清理：

config set activedefrag yes

然后，设置触发内存清理的条件：

*   **active-defrag-ignore-bytes 100mb**：表示内存碎片的字节数达到100MB时，开始清理；
*   **active-defrag-threshold-lower 10**：表示内存碎片空间占操作系统分配给Redis的总空间比例达到10%时，开始清理。

最后，控制清理操作占用CPU时间比例的上、下限：

*   **active-defrag-cycle-min 25**： 表示自动清理过程所用CPU时间的比例不低于25%，保证清理能正常开展；
*   **active-defrag-cycle-max 75**：表示自动清理过程所用CPU时间的比例不高于75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞Redis，导致响应延迟升高。

总结
--

*   **info memory**命令是一个好工具，可以帮助你查看碎片率的情况；
*   **碎片率阈值**是一个好经验，可以帮忙你有效地判断是否要进行碎片清理了；
*   **内存碎片自动清理**是一个好方法，可以避免因为碎片导致Redis的内存实际利用率降低，提升成本收益率。
*   如果你在实践过程中遇到Redis性能变慢，记得通过日志看下是否正在进行碎片清理。如果Redis的确正在清理碎片，那么，建议你**调小active-defrag-cycle-max的值**，以减轻对正常请求处理的影响。

参考资料
----

*   [20 | 删除数据后，为什么内存占用率还是很高？](https://time.geekbang.org/column/article/289140)