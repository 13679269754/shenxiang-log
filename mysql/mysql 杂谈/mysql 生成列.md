| operator | createtime | updatetime |
| ---- | ---- | ---- |
| shenx | 2025-7月-02 | 2025-7月-02  |
| ... | ... | ... |
---
# mysql 生成列

[toc]

在 MySQL 中，**生成列（Generated Columns）** 是一个统称，它分为两种类型：**虚拟生成列（VIRTUAL）** 和 **存储生成列（STORED）**。它们的核心区别在于 **值的存储方式** 和 **更新机制**。以下是详细解释：


### **一、生成列与虚拟列的核心区别**
| **特性**               | **虚拟生成列（VIRTUAL）**                | **存储生成列（STORED）**                 |
|------------------------|------------------------------------------|------------------------------------------|
| **值的存储**           | 不存储在磁盘，仅在查询时动态计算         | 物理存储在磁盘，与普通列相同             |
| **存储空间**           | 不占用额外空间                           | 占用存储空间，与计算结果大小相关         |
| **计算时机**           | 每次查询时计算                           | 插入/更新时计算并存储                   |
| **索引支持**           | 不能直接创建索引（但可通过函数索引间接支持） | 可直接创建索引，提升查询性能             |
| **更新开销**           | 查询时计算，写入快                       | 写入/更新时计算，可能影响写入性能       |
| **适用场景**           | 计算成本低、频繁更新的数据               | 计算成本高、频繁读取的数据               |


### **二、生成列的值是否会持久化？**
生成列的值是否持久化，取决于它的类型：

#### 1. **虚拟生成列（VIRTUAL）**
- **值不持久化**：仅在查询时根据当前数据动态计算，不会存储在磁盘。
- **依赖列更新时**：生成列会自动重新计算（但不存储）。

**示例**：
```sql
CREATE TABLE orders (
  price DECIMAL(10,2),
  tax_rate DECIMAL(3,2),
  total_amount DECIMAL(10,2) AS (price * (1 + tax_rate)) VIRTUAL  -- 虚拟生成列
);

INSERT INTO orders (price, tax_rate) VALUES (100, 0.1);  -- total_amount = 110.00

-- 修改依赖列（price）
UPDATE orders SET price = 200 WHERE price = 100;

-- 查询时重新计算total_amount（此时为220.00）
SELECT * FROM orders;
```

#### 2. **存储生成列（STORED）**
- **值持久化**：插入/更新时计算并存储在磁盘，与普通列相同。
- **依赖列更新时**：生成列会自动重新计算并更新存储的值。

**示例**：
```sql
CREATE TABLE orders (
  price DECIMAL(10,2),
  tax_rate DECIMAL(3,2),
  total_amount DECIMAL(10,2) AS (price * (1 + tax_rate)) STORED  -- 存储生成列
);

INSERT INTO orders (price, tax_rate) VALUES (100, 0.1);  -- 存储total_amount = 110.00

-- 修改依赖列（price）
UPDATE orders SET price = 200 WHERE price = 100;  -- 自动更新total_amount为220.00

-- 查询时直接读取存储的值（无需计算）
SELECT * FROM orders;
```


### **三、关键结论**
1. **生成列的值会自动更新**  
   无论虚拟还是存储生成列，当依赖的列值更新时，生成列会自动重新计算。区别在于：
   - 虚拟生成列在**查询时计算**，存储生成列在**写入/更新时计算**。

2. **持久化的含义**  
   - 虚拟生成列：值不持久化，每次查询时实时计算。
   - 存储生成列：值持久化，存储在磁盘，查询时直接读取。

3. **性能与存储权衡**  
   | **场景**               | **虚拟生成列（VIRTUAL）** | **存储生成列（STORED）** |
   |------------------------|--------------------------|--------------------------|
   | 写入频繁               | ✅ 无计算开销             | ❌ 写入时需计算          |
   | 读取频繁               | ❌ 每次查询都需计算       | ✅ 直接读取，性能高      |
   | 复杂计算（如聚合）     | ❌ 重复计算成本高         | ✅ 仅计算一次            |
   | 大数据量               | ✅ 节省存储空间           | ❌ 占用额外存储空间      |


### **四、最佳实践**
1. **选择虚拟生成列的场景**  
   - 计算逻辑简单（如加减乘除）。
   - 查询频率远低于写入频率。
   - 存储空间紧张。

2. **选择存储生成列的场景**  
   - 计算逻辑复杂（如多表关联、函数调用）。
   - 频繁查询生成列（如作为过滤条件）。
   - 需要对生成列创建索引。

3. **验证生成列类型**  
   ```sql
   -- 查看表结构，注意Extra列
   SHOW CREATE TABLE orders;
   
   -- 输出示例（虚拟生成列）：
   `total_amount` DECIMAL(10,2) AS (price * (1 + tax_rate)) VIRTUAL
   
   -- 输出示例（存储生成列）：
   `total_amount` DECIMAL(10,2) AS (price * (1 + tax_rate)) STORED
   ```


### **五、注意事项**
1. **生成列的依赖限制**  
   生成列的表达式只能引用**同一行**的其他列，不能引用其他表或非确定性函数（如 `RAND()`、`NOW()`）。

2. **索引与生成列**  
   - 存储生成列可直接创建索引，提升查询性能。
   - 虚拟生成列需通过函数索引间接支持（MySQL 8.0+）：
     ```sql
     CREATE INDEX idx_total ON orders ((price * (1 + tax_rate)));  -- 函数索引
     ```

3. **ALTER TABLE 修改生成列类型**  
   修改生成列类型（虚拟 ↔ 存储）会触发全量数据重写，谨慎操作：
   ```sql
   ALTER TABLE orders 
   MODIFY COLUMN total_amount DECIMAL(10,2) AS (price * (1 + tax_rate)) STORED;
   ```

通过合理选择生成列类型，可在保证数据一致性的同时，平衡存储成本和查询性能。