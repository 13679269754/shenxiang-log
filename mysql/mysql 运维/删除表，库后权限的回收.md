MySQL 的授权不仅可以是 `research.*`，还可能是 `research.tablename` 这样的形式。我们得把这两种都考虑进去。

下面是升级版的脚本，它会识别：

- `ON research.*`
- `ON research.tablename`
- `ON \`research`.*`
- `ON \`research`.`tablename``

并生成对应的 `REVOKE` 语句。

---

### 🛠️ 升级版 Bash 脚本：撤销所有 `research` 库相关权限

```bash
#!/bin/bash

MYSQL="mysql -uroot -p'your_password' -N -B"
TARGET_DB="research"
USER_LIST_FILE="user_list.txt"
OUTPUT_SQL="revoke_research_privs.sql"

> "$OUTPUT_SQL"

while read -r USER_ENTRY; do
    USER=$(echo "$USER_ENTRY" | cut -d'@' -f1 | tr -d "'")
    HOST=$(echo "$USER_ENTRY" | cut -d'@' -f2 | tr -d "'")

    echo "-- Checking $USER@$HOST" >> "$OUTPUT_SQL"

    GRANTS=$($MYSQL -e "SHOW GRANTS FOR '$USER'@'$HOST';")

    while read -r GRANT_LINE; do
        # 匹配所有 research.* 或 research.表名 的授权
        if echo "$GRANT_LINE" | grep -qE "ON \`?$TARGET_DB\`?\.\*|ON \`?$TARGET_DB\`?\.\`?[a-zA-Z0-9_]+\`?"; then
            # 提取权限和对象
            PRIVS=$(echo "$GRANT_LINE" | sed -n "s/^GRANT \(.*\) ON .\+ TO.*/\1/p")
            OBJECT=$(echo "$GRANT_LINE" | sed -n "s/^GRANT .* ON \(.*\) TO.*/\1/p")
            echo "REVOKE $PRIVS ON $OBJECT FROM '$USER'@'$HOST';" >> "$OUTPUT_SQL"
        fi
    done <<< "$GRANTS"

done < "$USER_LIST_FILE"

echo "生成完成：$OUTPUT_SQL"
```

### 📄 user_list.txt 示例内容（你可以复制你那堆用户进去）：

```
SELECT CONCAT(USER,'@','''',HOST,'''') FROM mysql.user WHERE USER NOT IN ('mysql.infoschema','mysql.session','mysql.sys','root') AND HOST NOT IN ('localhost');
```

```
'app_dzj_read'@'%'
'app_dzj_rw'@'%'
'app_dzj_rwuser'@'%'
'archery_user'@'%'
'dba_guanxin'@'%'
...
```

---

### 🧪 使用方式：

1. 把脚本保存为 `gen_revoke.sh`；
2. 把用户列表保存为 `user_list.txt`；
3. 修改脚本中的 `your_password`；
4. 运行脚本：

```bash
bash gen_revoke.sh
```
---

### 示例输出（自动生成的 SQL）：

```sql
REVOKE SELECT, INSERT ON `research`.* FROM 'app_dzj_rw'@'%';
REVOKE SELECT ON `research`.`sensitive_table` FROM 'dzj_reporter'@'%';
```

---

这个脚本会帮你彻底清理掉所有 `research` 库相关的授权，无论是库级别还是表级别。🧹

如果你想让它直接执行 revoke 而不是生成 SQL 文件，也可以加个选项来控制。要我帮你加上吗？🦊